<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CapÃ­tulo 6 - IntroduÃ§Ã£o ao Machine Learning</title>
  <link rel="stylesheet" href="style/style-pages.css" />
</head>

<body>
  <header>
    <h1>ğŸ¤– CapÃ­tulo 6 â€” Machine Learning (Aprendizado de MÃ¡quina)</h1>
  </header>

  <main>
    <p><em>â€œA inteligÃªncia artificial nÃ£o Ã© um truque de mÃ¡gica â€” Ã© matemÃ¡tica, estatÃ­stica e paciÃªncia.â€</em></p>

    <h2>ğŸ¯ O que Ã© Machine Learning?</h2>
    <p>
      <strong>Machine Learning (ML)</strong> Ã© o campo da ciÃªncia de dados que ensina computadores
      a **aprender a partir de dados**, sem que precisemos programar cada regra manualmente.
    </p>

    <p>
      Pense assim: em vez de dizer ao computador â€œse a temperatura for acima de 30, Ã© quenteâ€,
      nÃ³s mostramos exemplos de temperaturas e deixamos ele **descobrir sozinho** o padrÃ£o que define o que Ã© â€œquenteâ€.
    </p>

    <div class="tip-box">
      ğŸ’¡ <strong>DefiniÃ§Ã£o prÃ¡tica:</strong>  
      Machine Learning Ã© quando um programa melhora automaticamente sua performance conforme recebe mais dados.
    </div>

    <hr>

    <h2>ğŸ§  Mas... como uma mÃ¡quina â€œaprendeâ€?</h2>
    <p>
      Aprender, para uma mÃ¡quina, significa **ajustar parÃ¢metros matemÃ¡ticos** atÃ© que suas previsÃµes fiquem prÃ³ximas da realidade.
      Esses parÃ¢metros sÃ£o como â€œbotÃµezinhosâ€ internos que o modelo gira, testando combinaÃ§Ãµes, atÃ© errar menos.
    </p>

    <pre class="pretty-code"><code>
# Exemplo simbÃ³lico: uma mÃ¡quina tentando prever notas de alunos
erro = previsÃ£o - nota_real
ajuste = taxa_de_aprendizado * erro
peso = peso - ajuste
    </code></pre>

    <p>
      Ela compara a previsÃ£o com o resultado real (isso Ã© o <strong>erro</strong>), aprende com ele e ajusta.
      Repetindo isso milhares de vezes, o modelo comeÃ§a a "acertar" sozinho.
    </p>

    <div class="exercise-box">
      ğŸ§© <strong>Analogia:</strong>  
      Ã‰ como aprender a arremessar uma bola de basquete.  
      No inÃ­cio, vocÃª erra vÃ¡rias vezes, mas ajusta a forÃ§a e o Ã¢ngulo atÃ© acertar o cesto.  
      O modelo faz o mesmo â€” sÃ³ que com nÃºmeros.
    </div>

    <hr>

    <h2>ğŸ“Š RegressÃ£o Linear â€” a base de tudo</h2>
    <p>
      A <strong>RegressÃ£o Linear</strong> Ã© o primeiro passo do aprendizado supervisionado.
      Ela tenta encontrar uma <strong>linha</strong> (ou equaÃ§Ã£o) que melhor descreve a relaÃ§Ã£o entre duas variÃ¡veis.
    </p>

    <h3>ğŸ“ FÃ³rmula da reta:</h3>
    <pre class="pretty-code"><code>
y = a * x + b
</code></pre>

    <p>
      Onde:
      <ul>
        <li><strong>y</strong> â†’ variÃ¡vel dependente (o que queremos prever)</li>
        <li><strong>x</strong> â†’ variÃ¡vel independente (entrada)</li>
        <li><strong>a</strong> â†’ inclinaÃ§Ã£o (o quanto y muda quando x muda)</li>
        <li><strong>b</strong> â†’ intercepto (ponto inicial)</li>
      </ul>
    </p>

    <pre class="pretty-code"><code>
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression

# Dados simulados: tamanho do imÃ³vel (mÂ²) e preÃ§o (em mil R$)
x = np.array([40, 50, 60, 70, 80]).reshape(-1, 1)
y = np.array([200, 250, 300, 350, 400])

modelo = LinearRegression()
modelo.fit(x, y)

a = modelo.coef_[0]
b = modelo.intercept_

print(f"EquaÃ§Ã£o: preÃ§o = {a:.2f} * tamanho + {b:.2f}")
print(f"PrediÃ§Ã£o para 65mÂ²: {modelo.predict([[65]])[0]:.2f} mil R$")

plt.scatter(x, y, color="#38bdf8", label="Dados reais")
plt.plot(x, modelo.predict(x), color="#a855f7", label="Linha de RegressÃ£o")
plt.legend(); plt.show()
    </code></pre>

    <div class="tip-box">
      ğŸ’¡ <strong>ExplicaÃ§Ã£o:</strong>  
      O modelo encontrou uma linha que â€œmelhor se encaixaâ€ nos dados.  
      Essa linha Ã© uma **equaÃ§Ã£o aprendida** â€” e ela representa o conhecimento do modelo.
    </div>

    <hr>

    <h2>ğŸ§© A MatemÃ¡tica por TrÃ¡s</h2>
    <p>
      O modelo tenta minimizar o erro, calculado pela fÃ³rmula:
    </p>

    <pre class="pretty-code"><code>
Erro QuadrÃ¡tico MÃ©dio (MSE) = Î£ (y_real - y_previsto)Â² / n
</code></pre>

    <p>
      Ele ajusta os coeficientes (a e b) atÃ© que o MSE seja o menor possÃ­vel.
      Isso Ã© feito por um processo chamado **gradiente descendente** â€” o modelo â€œdesceâ€ a montanha do erro atÃ© o vale mais baixo.
    </p>

    <div class="exercise-box">
      ğŸ¯ <strong>Desafio:</strong>  
      Crie uma regressÃ£o linear para prever o preÃ§o de carros a partir da quilometragem.  
      Veja como os coeficientes mudam se vocÃª adicionar mais dados.
    </div>

    <hr>

    <h2>ğŸ ClassificaÃ§Ã£o â€” DecisÃµes AutomÃ¡ticas</h2>
    <p>
      Na <strong>classificaÃ§Ã£o</strong>, o objetivo Ã© prever **categorias**, e nÃ£o nÃºmeros.  
      Por exemplo: â€œcompraâ€ ou â€œnÃ£o compraâ€, â€œspamâ€ ou â€œnÃ£o spamâ€.
    </p>

    <h3>ğŸŒ³ Ãrvores de DecisÃ£o</h3>
    <p>
      As Ãrvores de DecisÃ£o simulam o raciocÃ­nio humano:  
      fazem perguntas (â€œa renda Ã© alta?â€) e seguem caminhos atÃ© chegar a uma conclusÃ£o.
    </p>

    <pre class="pretty-code"><code>
from sklearn.tree import DecisionTreeClassifier

X = [[22, 2000], [35, 3500], [45, 5000], [52, 5200], [23, 1800]]
y = ["NÃ£o compra", "Compra", "Compra", "Compra", "NÃ£o compra"]

modelo = DecisionTreeClassifier(max_depth=3)
modelo.fit(X, y)

pred = modelo.predict([[30, 3000]])
print("Cliente com 30 anos e renda 3000 â†’", pred[0])
    </code></pre>

    <div class="tip-box">
      ğŸ’¡ <strong>Como funciona:</strong>  
      A Ã¡rvore divide os dados em â€œramosâ€ atÃ© chegar a uma folha â€” a decisÃ£o final.  
      Cada divisÃ£o reduz a incerteza (ou â€œentropiaâ€) dos dados.
    </div>

    <hr>

    <h2>ğŸ§® Agrupamento â€” Descobrindo padrÃµes ocultos</h2>
    <p>
      O <strong>K-Means</strong> Ã© um algoritmo **nÃ£o supervisionado**, usado para agrupar dados parecidos.
      Ele nÃ£o precisa de respostas â€” apenas dos prÃ³prios dados.
    </p>

    <pre class="pretty-code"><code>
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
import numpy as np

# Dados aleatÃ³rios
X = np.random.rand(100, 2)

modelo = KMeans(n_clusters=3, random_state=42)
modelo.fit(X)

plt.scatter(X[:,0], X[:,1], c=modelo.labels_, cmap="viridis")
plt.scatter(modelo.cluster_centers_[:,0], modelo.cluster_centers_[:,1], color="red", marker="x")
plt.title("Agrupamento com K-Means")
plt.show()
    </code></pre>

    <div class="tip-box">
      ğŸ’¡ <strong>Como ele â€œaprendeâ€:</strong>  
      Ele escolhe pontos centrais (chamados de *centroides*) e move-os atÃ© que os grupos fiquem bem definidos.  
      O objetivo Ã© minimizar a distÃ¢ncia entre os pontos e seus centroides.
    </div>

    <hr>

    <h2>âš™ï¸ Como o Python se encaixa nisso?</h2>
    <p>
      Python Ã© a linguagem mais usada em IA porque combina **simplicidade** e **poder matemÃ¡tico**.
      Bibliotecas como:
    </p>
    <ul>
      <li><strong>NumPy</strong> â€” para cÃ¡lculos vetoriais e matrizes</li>
      <li><strong>Pandas</strong> â€” para manipulaÃ§Ã£o de dados</li>
      <li><strong>Matplotlib / Seaborn</strong> â€” para grÃ¡ficos</li>
      <li><strong>Scikit-learn</strong> â€” para algoritmos de ML prontos</li>
      <li><strong>TensorFlow / PyTorch</strong> â€” para redes neurais e IA avanÃ§ada</li>
    </ul>

    <div class="exercise-box">
      ğŸ§  <strong>ReflexÃ£o:</strong>  
      Quando vocÃª escreve cÃ³digo em Python, vocÃª nÃ£o â€œcria uma IA do zeroâ€ â€”  
      vocÃª **usa bibliotecas** que encapsulam anos de pesquisa em algoritmos matemÃ¡ticos complexos.
    </div>

    <hr>

    <h2>ğŸ§© Redes Neurais â€” o cÃ©rebro das mÃ¡quinas</h2>
    <p>
      As redes neurais sÃ£o inspiradas no funcionamento do cÃ©rebro humano.  
      Elas aprendem ajustando pesos entre â€œneurÃ´niosâ€ que processam sinais numÃ©ricos.
    </p>

    <pre class="pretty-code"><code>
import tensorflow as tf
from tensorflow.keras import layers

modelo = tf.keras.Sequential([
    layers.Dense(8, activation='relu', input_shape=(2,)),
    layers.Dense(4, activation='relu'),
    layers.Dense(1, activation='sigmoid')
])

modelo.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
modelo.summary()
    </code></pre>

    <div class="tip-box">
      âš™ï¸ <strong>InterpretaÃ§Ã£o:</strong>  
      Cada camada transforma os dados de forma nÃ£o linear â€”  
      o modelo cria abstraÃ§Ãµes, entende padrÃµes complexos e ajusta seus â€œpesosâ€ com base no erro.
    </div>

    <hr>

    <h2>ğŸ§­ Resumo do CapÃ­tulo</h2>
    <ul>
      <li>âœ… Machine Learning aprende padrÃµes a partir de dados</li>
      <li>âœ… RegressÃ£o linear explica a base matemÃ¡tica do aprendizado</li>
      <li>âœ… Ãrvores de decisÃ£o e K-Means permitem previsÃµes e agrupamentos</li>
      <li>âœ… Python Ã© o idioma universal da IA moderna</li>
      <li>âœ… Redes neurais sÃ£o a base da inteligÃªncia artificial atual</li>
    </ul>

    <div class="tip-box">
      ğŸ“ <strong>ParabÃ©ns!</strong>  
      VocÃª agora entende nÃ£o sÃ³ como aplicar Machine Learning, mas **como ele pensa**.  
      No prÃ³ximo capÃ­tulo, vamos explorar o mundo do <strong>Big Data</strong> â€”  
      onde tudo isso acontece em escala massiva. ğŸŒ
    </div>

    <div class="chapter-nav">
      <a href="estatistica.html" class="nav-link">â† CapÃ­tulo 5: EstatÃ­stica</a>
      <a href="big-data.html" class="nav-link">PrÃ³ximo: Big Data â†’</a>
    </div>
  </main>
</body>
</html>
